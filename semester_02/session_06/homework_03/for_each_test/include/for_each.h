// for_each.h

#ifndef FOR_EACH_H
#define FOR_EACH_H

#include <future>

namespace my
{
	template<std::forward_iterator ForwardIter, typename UnaryFunc>
	auto for_each(ForwardIter first, ForwardIter last, UnaryFunc func) -> void
	{
		if (const auto distance = std::distance(first, last), 
			max_number_elem = static_cast<decltype(std::distance(first, last))>(10'000);
			distance < max_number_elem)
		{
			std::for_each(first, last, func);
			return;
		}
		else {
			const auto median = first + distance / 2;
			auto fa = std::async(std::launch::async, my::for_each<ForwardIter, UnaryFunc>, first, median, func);
			auto fd = std::async(std::launch::deferred, my::for_each<ForwardIter, UnaryFunc>, median, last, func);
			fa.get(); fd.get();
		}
	}
} // namespace my

#endif // !FOR_EACH_H

/*
* launch::async – если передан этот флаг, то поведение async будет следующим: будет создан объект класса thread, 
* с функцией и её аргументами в качестве аргументов нового потока. Т.е.async инкапсулирует  создание потока, 
* получение future и предоставляет однострочную запись для выполнения такого кода(скорее всего реализация будет
* использовать packaged_task, вместо простой передачи функции в поток).
*
* launch::deferred – если передан этот флаг, то имя функции async становится несколько не логичным. Т.к.никакого
* асинхронного вызова не произойдёт. Вместо исполнения функции в новом потоке, она, вместе с аргументами, будет
* сохранена в future(еще одна особенность future), чтобы быть вызванными позже. Это позже наступит тогда, когда
* кто - либо вызовет метод get, или wait на future, которое вернул async. При этот вызываемый объект выполнится
* в потоке, который вызывал get! Это поведение есть ни что иное, как отложенный вызов процедуры.
* 
* launch::async | launch::deferred - в этом случае будет выбрано одно из двух поведений описанных выше.
* Какое из двух ? Неизвестно и зависит от имплементации.
* 
* std::async с флагом  launch::async является удобной заменой std::packaged_task и прямого использования std::thread.
* Т.е. есть смысл всегда использовать её в тех местах, где нет явной необходимости в использовании std::thread и 
* std::packaged_task. Например, когда есть необходимость в создании отдельного потока на каждую задачу.
* 
* std::async, с флагом launch::deffered, удобно использовать в случае необходимого отложенного вычисления не
* требовательного к ресурсам, т.е. того которое может быть быстро вычислено в месте его получения.
*/

/*
* std::execution::seq - nип политики выполнения, используемый как уникальный тип для устранения неоднозначности перегрузки
* параллельного алгоритма и требующий, чтобы выполнение параллельного алгоритма не могло быть распараллелено. Вызовы функций
* доступа к элементам в параллельных алгоритмах, вызываемых с этой политикой, неопределенно упорядочены в вызывающем потоке.

* std::execution::par - тип политики выполнения, используемый как уникальный тип для устранения неоднозначности перегрузки
* параллельного алгоритма и указания того, что выполнение параллельного алгоритма может быть распараллелено. Вызовы функций
* доступа к элементам в параллельных алгоритмах, вызываемых с этой политикой, могут выполняться либо в вызывающем потоке,
* либо в потоке, неявно созданном библиотекой для поддержки выполнения параллельного алгоритма. Любые такие вызовы,
* выполняемые в одном потоке, неопределенно упорядочены относительно друг друга. Если потоки выполнения,
* созданные std::thread или std::jthread, предоставляют гарантии параллельного продвижения вперед, то потоки выполнения,
* созданные библиотекой, предоставляют гарантии параллельного продвижения вперед. В противном случае предоставляемая гарантия
* продвижения вперед определяется реализацией.
* Примечание: параллельное продвижение вперед гарантирует, что если поток выполнения делает шаг, он в конечном итоге сделает
* еще один шаг, позволяя потокам входить в критические разделы и брать блокировки, поскольку поток, имеющий блокировку,
* в конечном итоге будет снова запланирован и сможет снять ее.

* parallel_unsequenced_policy - тип политики выполнения, используемый в качестве уникального типа для устранения
* неоднозначности перегрузки параллельного алгоритма и указания того, что выполнение параллельного алгоритма может быть
* распараллелено, векторизовано или перенесено между потоками (например, планировщиком захвата родителя).
* Вызовы функций доступа к элементам в параллельных алгоритмах, вызываемые с этой политикой, могут выполняться неупорядоченным
* образом в неуказанных потоках и непоследовательно по отношению друг к другу в каждом потоке. Вызов функций доступа
* к элементам в параллельных алгоритмах, вызываемых с этой политикой, не позволяет вызывать операции, небезопасные
* для векторизации, такие как те, которые указаны стандартной библиотекой для синхронизации, включая std::atomic
* и другие примитивы параллельности. Если потоки выполнения, созданные std::thread или std::jthread, предоставляют гарантии
* параллельного продвижения вперед, то потоки выполнения, созданные библиотекой, предоставляют гарантии слабопараллельного
* продвижения вперед. В противном случае предоставляемая гарантия продвижения вперед — это гарантия потока, вызывающего
* параллельный алгоритм. Примечание: слабопараллельный прогресс вперед гарантирует, что один из потоков выполнения,
* выполнивших шаг, в конечном итоге выполнит другой шаг, что не позволяет потокам входить в критические разделы или брать
* блокировки, поскольку поток, имеющий блокировку, не может быть запланирован снова, пока поток, пытающийся взять блокировку,
* не завершит работу.

* unsequenced_policy - тип политики выполнения, используемый как уникальный тип для устранения неоднозначности перегрузки
* параллельного алгоритма и указания того, что выполнение параллельного алгоритма может быть векторизовано, например,
* выполнено в одном потоке с использованием инструкций, которые работают с несколькими элементами данных.
*/

/*
ХВОСТОВАЯ РЕКУРСИЯ - форма прямой рекурсии, при которой рекурсивный вызов является последней
операцией в функции. Она используется для решения задач, связанных с накоплением данных
и обработкой списков
int factorial(int n, int result = 1)
{
	if (n <= 1)
		return result;
	else
		return factorial(n - 1, n * result);
}

ГОЛОВНАЯ РЕКУРСИЯ - рекурсивный вызов выполняется перед любой другой операцией в функции.
Обработка происходит после возврата из рекурсивного вызова. Он используется для обхода
дерева и генерации вывода
void print_numbers(int n)
{
	if (n > 0)
	{
		print_numbers(n - 1);
		std::cout << n << ' ';
	}
}

ЛИНЕЙНАЯ РЕКУРСИЯ - каждый вызов функции генерирует ровно один рекурсивный вызов,
образуя линейную цепочку вызовов. Это используется для простого подсчёта или суммирования
int linear_recursion(int n)
{
	if (n <= 0)
		return 0;
	else
		return linear_recursion(n - 1) + 1;
}
*/