// Нужно реализовать класс парсера INI-файлов, который предоставляет для пользователя одну шаблонную функцию,
// позволяющую получить значение переменной в определённой секции.
// Если в файле нет значения для этой переменной, то нужно бросить исключение.
// Если есть проблемы со считываением файла или файл некорректный, то нужно сообщить об этом в исключении.
// 
// Если файл содержит некорректный синтаксис, нужно указать в исключении, на какой строке встретилась проблема.
// Если искомого значения переменной нет, нужно вывести подсказку для пользователя — названия других переменных
// из этой секции.Возможно, пользователь опечатался.


// Лексема - это строка символов, которая является синтаксической единицей самого низкого уровня в языке программирования. 
// Токен - это синтаксическая категория, которая образует класс лексем, который означает, к какому классу принадлежит лексема, 
// является ли она ключевым словом, идентификатором или чем-то еще.

// [Token]      [Informal Description]                  [Sample Lexemes]
// if           characters i, f                         if
// else         characters e, l, s, e                   else
// comparison   < or > or <= or >= or == or !=          <=, !=
// id           letter followed by letters and digits   pi, score, D2
// number       any numeric constant                    3.14159, 0, 6.02e23
// literal      anything but ", surrounded by "'s       "core dumped"

// Терминалы и нетерминалы.
// Описание грамматики представляет набор правил, определяющих отношения между терминальными символами и нетерминальными символами.
// 1. Терминалы — это минимальные элементы грамматики, не имеющие собственной грамматической структуры. Терминальные символы — это либо
// предопределённые идентификаторы (имена, считающиеся заданными для данного описания грамматики), либо цепочки — последовательности
// символов в кавычках или апострофах.
// 2. Нетерминалы — это элементы грамматики, имеющие собственные имена и структуру. Каждый нетерминальный символ состоит из одного или более
// терминальных и / или нетерминальных символов, сочетание которых определяется правилами грамматики. Каждый нетерминальный символ имеет имя, 
// которое представляет собой строку символов.

// Правила имеет вид : идентификатор = выражение.
// где идентификатор — имя нетерминального символа, а выражение — соответствующая правилам комбинация терминальных и нетерминальных символов
// и специальных знаков. Точка в конце — специальный символ, указывающий на завершение правила. Семантика правила — нетерминальный символ,
// заданный идентификатором слева от знака «равно», представляет собой определяемую выражением комбинацию терминальных и нетерминальных символов.
// Полное описание грамматики представляет собой набор правил, который последовательно определяет все нетерминальные символы грамматики так,
// что каждый нетерминальный символ может быть сведён к комбинации терминальных символов путём последовательного(рекурсивного) применения правил.
// В определении нет никаких специальных предписаний относительно порядка записи правил, хотя такие предписания могут вводиться при использовании
// программными средствами, обеспечивающими автоматическую генерацию программ синтаксического разбора по описанию грамматики.

// Выражения
// Набор возможных конструкций невелик: конкатенация, выбор, условное вхождение и повторение.
// 1. Конкатенация - определяется символом "," (запятая). 
// Правило вида A = B, C. обозначает, что нетерминал A состоит из двух символов — B и C. Элементы конкатенации называют ещё синтаксическими факторами,
// или просто факторами. В данном примере B и C — синтаксические факторы.
// 2. Выбор - обозначается вертикальной чертой.
// Правило вида A = B | C | D. обозначает, что нетерминал A может состоять либо из B, либо из C, либо из D. Элементы выбора называют ещё синтаксическими термами,
// или просто термами. В данном примере B, C, D — синтаксические термы.
// 3. Условное вхождение - квадратные скобки выделяют необязательный элемент выражения, который может присутствовать, а может и отсутствовать.
// Правило вида A = [B]. обозначает, что нетерминал A либо является пустым, либо состоит из символа B.
// 4. Повторение - фигурные скобки обозначают конкатенацию любого числа(включая нуль) записанных в ней элементов.
// Правило вида A = { B }. обозначает, что A — либо пустой, либо представляет собой конкатенацию любого числа символов B(то есть A — это либо пустой элемент,
// либо B, либо BB, либо BBB и так далее). Если требуется, чтобы A представлял собой либо B, либо произвольное число B, но не мог быть пустым, используется запись A = B{ B }.
// Помимо основных операций, могут использоваться обычные круглые скобки. Они применяются для группировки элементов при формировании сложных выражений.
// Например, правило A = (B | C)(D | E). обозначает, что A состоит из двух символов, первым из которых является либо B, либо C, вторым — либо D, либо E,
// то есть A может быть одной из цепочек BD, BE, CD, CE.
// 5. Не общепринято! Также иногда имеет смысл использовать отрицание. Например, A = (B | D)!C. означает, что A может быть B или D, но не BC или DC.
// Такой вариант позволяет четко отличить A от G = (B | D)C и упростить процедуру разбора.
// 6. Не общепринято! Определение цифры включает в себя 10 символов — от '0' до '9'. 
// Вполне логично описать понятие «цифра» перечислением : Digit = '0' | '1' | '2' | ... | '9'. Также можно определить понятие «символ».

// Или все вышеуказанное вкратце:
// лексема « = » её описание(или « ::= »)
// '…' — текстовый элемент — символ или группа символов
// A, B — элемент A, за которым следует элемент B(конкатенация)
// A | B — либо элемент A либо B(выбор)
// [A] — элемент A входит или не входит(условное вхождение)
// {A} — ноль или более элементов A(повторение)
// (A B) — группировка элементов

// Метод рекурсивного спуска (англ. Recursive descent parser) — алгоритм нисходящего синтаксического анализа, реализуемый путём взаимного вызова процедур,
// где каждая процедура соответствует одному из правил контекстно-свободной грамматики. Применения правил последовательно, слева направо поглощают токены,
// полученные от лексического анализатора. Это один из самых простых алгоритмов синтаксического анализа, подходящий для полностью ручной реализации.
// 1. Предсказывающий парсер. Для парсеров этого типа нужна подходящая КС - грамматика, конкретно — LL(k) грамматика, позволяющая по очередному токену 
// или токенам однозначно выбрать(предсказать) один из альтернативных вариантов раскрытия каждого нетерминала. Такой парсер работает за линейное время.
// Вариантом является LL - парсер — реализация предсказывающего парсера с автоматическим построением «таблицы предсказания», определяющей по заданному нетерминалу
// и очередному токену подходящее правило для раскрытия нетерминала.
// 2. Парсер с возвратом. Вместо предсказания парсер просто пытается применить все альтернативные варианты правил по порядку, пока одна из попыток не увенчается успехом.
// Такой парсер может потребовать экспоненциального времени работы, и не всегда гарантирует завершение, в зависимости от грамматики. Уязвим для левой рекурсии.

// Распознаватели. Существуют два разных класса распознавателей(автоматов для распознавания) КС - языков. Их названия связаны с порядком построения дерева вывода.
// Как правило, все распознаватели читают входную цепочку символов слева направо, поскольку предполагается такая нотация в написании исходного текста программ.
// 1. Нисходящие распознаватели порождают цепочки левостороннего вывода и строят дерево вывода сверху вниз. Они используют модификации алгоритма с подбором альтернатив.
// При их создании применяется метод, который позволяет однозначно выбрать одну и только одну альтернативу на каждом шаге работы МП - автомата(шаг «выброс» в этом автомате
// всегда выполняется однозначно).
// 2. Восходящие распознават порождают цепочки правостороннего вывода и строят дерево вывода снизу вверх. Восходящие распознаватели используют модификации алгоритма 
// «сдвиг - свертка»(или «перенос - свертка», что то же самое). При их создании применяются методы, которые позволяют однозначно выбрать между выполнением «сдвига»(«переноса»)
// или «свертки» на каждом шаге работы расширенного МП - автомата, а при выполнении свертки однозначно выбрать правило, по которому будет производиться свертка.